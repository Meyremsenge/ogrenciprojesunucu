# ==============================================
# KUBERNETES SECRETS CONFIGURATION
# ==============================================
# Production ortamı için Kubernetes secrets.
#
# Kullanım:
#   1. Bu dosyayı kopyalayın: cp secrets.yaml secrets-production.yaml
#   2. Base64 encode edilmiş değerlerle doldurun
#   3. kubectl apply -f secrets-production.yaml
#
# NOT: Bu dosya template olarak kullanılmalı.
# Gerçek secrets değerleri için:
#   - Sealed Secrets ile şifrelenmeli
#   - External Secrets Operator ile çekilmeli
#   - HashiCorp Vault ile yönetilmeli
#
# Base64 encoding:
#   echo -n "your-secret-value" | base64
#
# Base64 decoding:
#   echo "encoded-value" | base64 -d
# ==============================================

---
# Secret - Sensitive configuration
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: ogrenci-sistemi
  labels:
    app: ogrenci-sistemi
    environment: production
type: Opaque
data:
  # Flask Security (base64 encoded)
  # Generate: python -c "import secrets; print(secrets.token_hex(32))"
  SECRET_KEY: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  JWT_SECRET_KEY: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  
  # Database
  # Format: postgresql://user:password@host:port/dbname
  DATABASE_URL: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  DATABASE_PASSWORD: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  
  # Redis
  REDIS_PASSWORD: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  REDIS_URL: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  
  # Celery
  CELERY_BROKER_URL: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  CELERY_RESULT_BACKEND: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  
  # Email/SMTP
  MAIL_USERNAME: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  MAIL_PASSWORD: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  
  # External APIs
  YOUTUBE_API_KEY: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  OPENAI_API_KEY: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  SENTRY_DSN: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  
  # AWS S3 (optional)
  AWS_ACCESS_KEY_ID: "REPLACE_WITH_BASE64_ENCODED_VALUE"
  AWS_SECRET_ACCESS_KEY: "REPLACE_WITH_BASE64_ENCODED_VALUE"

---
# Example: Creating secrets with kubectl
# kubectl create secret generic app-secrets \
#   --from-literal=SECRET_KEY='your-secret-key' \
#   --from-literal=JWT_SECRET_KEY='your-jwt-secret' \
#   --from-literal=DATABASE_URL='postgresql://user:pass@host:5432/db' \
#   --from-literal=REDIS_URL='redis://:password@host:6379/0' \
#   -n ogrenci-sistemi
  REDIS_SSL: "false"
  
  # Cache
  CACHE_TYPE: "redis"
  CACHE_DEFAULT_TIMEOUT: "300"
  CACHE_KEY_PREFIX: "sks:"
  
  # Rate Limiting
  RATELIMIT_ENABLED: "true"
  RATELIMIT_DEFAULT: "100/minute"
  
  # Logging
  LOG_LEVEL: "WARNING"
  
  # Pagination
  DEFAULT_PAGE_SIZE: "20"
  MAX_PAGE_SIZE: "100"
  
  # Security
  SESSION_COOKIE_SECURE: "true"
  SESSION_COOKIE_HTTPONLY: "true"
  SESSION_COOKIE_SAMESITE: "Strict"
  BCRYPT_LOG_ROUNDS: "13"
  WTF_CSRF_ENABLED: "true"

---
# Secret - Sensitive values
# ⚠️  WARNING: Base64 encoded values - NOT encrypted!
# Use Sealed Secrets or External Secrets in production.
apiVersion: v1
kind: Secret
metadata:
  name: sks-secrets
  namespace: production
  labels:
    app: student-coaching-system
    environment: production
type: Opaque
data:
  # Placeholder values - replace with actual base64 encoded secrets
  # echo -n "your-actual-secret" | base64
  SECRET_KEY: "REPLACE_WITH_BASE64_ENCODED_SECRET_KEY"
  JWT_SECRET_KEY: "REPLACE_WITH_BASE64_ENCODED_JWT_SECRET"
  DB_PASSWORD: "REPLACE_WITH_BASE64_ENCODED_DB_PASSWORD"
  REDIS_PASSWORD: "REPLACE_WITH_BASE64_ENCODED_REDIS_PASSWORD"
  
  # Email credentials
  MAIL_USERNAME: ""
  MAIL_PASSWORD: ""
  
  # AWS credentials (if using S3)
  AWS_ACCESS_KEY_ID: ""
  AWS_SECRET_ACCESS_KEY: ""
  
  # External services
  YOUTUBE_API_KEY: ""
  ZOOM_API_KEY: ""
  ZOOM_API_SECRET: ""
  GOOGLE_CLIENT_ID: ""
  GOOGLE_CLIENT_SECRET: ""
  SENTRY_DSN: ""

---
# External Secrets - For HashiCorp Vault integration
# Requires External Secrets Operator installed
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: sks-vault-secrets
  namespace: production
  labels:
    app: student-coaching-system
spec:
  refreshInterval: 1h
  secretStoreRef:
    kind: ClusterSecretStore
    name: vault-backend
  target:
    name: sks-secrets-from-vault
    creationPolicy: Owner
  data:
    - secretKey: SECRET_KEY
      remoteRef:
        key: secret/data/sks/production
        property: secret_key
    - secretKey: JWT_SECRET_KEY
      remoteRef:
        key: secret/data/sks/production
        property: jwt_secret_key
    - secretKey: DB_PASSWORD
      remoteRef:
        key: secret/data/sks/production
        property: db_password
    - secretKey: REDIS_PASSWORD
      remoteRef:
        key: secret/data/sks/production
        property: redis_password
    - secretKey: SENTRY_DSN
      remoteRef:
        key: secret/data/sks/production
        property: sentry_dsn

---
# Sealed Secret Example
# Requires Sealed Secrets Controller
# kubeseal --format=yaml < secret.yaml > sealed-secret.yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: sks-sealed-secrets
  namespace: production
  labels:
    app: student-coaching-system
spec:
  encryptedData:
    # These would be sealed (encrypted) values
    SECRET_KEY: "AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq..."
    JWT_SECRET_KEY: "AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq..."
  template:
    metadata:
      name: sks-secrets
      namespace: production
    type: Opaque

---
# ServiceAccount for accessing secrets
apiVersion: v1
kind: ServiceAccount
metadata:
  name: sks-service-account
  namespace: production
  labels:
    app: student-coaching-system

---
# Pod example showing secret usage
apiVersion: v1
kind: Pod
metadata:
  name: sks-api-example
  namespace: production
spec:
  serviceAccountName: sks-service-account
  containers:
    - name: api
      image: sks-api:latest
      envFrom:
        # Load all ConfigMap values as env vars
        - configMapRef:
            name: sks-config
        # Load all Secret values as env vars
        - secretRef:
            name: sks-secrets
      env:
        # Or load specific values
        - name: DATABASE_URL
          value: "postgresql://$(DB_USER):$(DB_PASSWORD)@$(DB_HOST):$(DB_PORT)/$(DB_NAME)"
        - name: REDIS_URL
          value: "redis://:$(REDIS_PASSWORD)@$(REDIS_HOST):$(REDIS_PORT)/$(REDIS_DB)"
      volumeMounts:
        # Mount secrets as files
        - name: secrets-volume
          mountPath: "/etc/secrets"
          readOnly: true
  volumes:
    - name: secrets-volume
      secret:
        secretName: sks-secrets
